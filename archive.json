{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-07-16T01:14:21.721495+00:00",
  "repo": "ietf-wg-keytrans/draft-arch",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "pr-ready",
      "description": "",
      "color": "E90CE2"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOKhdr7c52lG3E",
      "title": "what happens (to users) if a keyserver goes bad?",
      "url": "https://github.com/ietf-wg-keytrans/draft-arch/issues/1",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "We have a history of some key servers going bad. That could be due to attack, inability to operate or for other reasons. Regardless of the reason though, shouldn't the architecture describe e.g. a set of goals for how users and/or the overall system can recover from such a situation?",
      "createdAt": "2023-11-12T14:55:36Z",
      "updatedAt": "2024-02-15T00:09:25Z",
      "closedAt": "2024-02-15T00:09:25Z",
      "comments": [
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(chair hat off)\r\n\r\nI am not sure if this section implies redundancy or not, but perhaps its enough to convince readers its in scope?\r\n\r\nhttps://bren2010.github.io/draft-kt-arch/draft-mcmillion-keytrans-architecture.html#name-third-party-auditing",
          "createdAt": "2023-12-06T21:02:29Z",
          "updatedAt": "2023-12-06T21:02:29Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "NONE",
          "body": "Doesn't seem to address the issue as I read it. I think text about how a new log could potentially take over from an old one with the help of auditors of the old log or something like that might do the trick though. I guess that'd be a form of portability? Or maybe as you say, if common practice was for end users to not only use one log but to commonly make use of >1 independent logs, then maybe that'd be enough. I do think covering such issues in an architecture document would be needed or it'd never be covered later though.",
          "createdAt": "2023-12-06T21:07:43Z",
          "updatedAt": "2023-12-06T21:07:43Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDOKhdr7c56DKuE",
      "title": "Definition of KT",
      "url": "https://github.com/ietf-wg-keytrans/draft-arch/issues/2",
      "state": "CLOSED",
      "author": "eshaghoshms",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "pr-ready"
      ],
      "body": "The Introduction says, \"Any malicious entries added to such a log will generally be visible to all users, in which case a user can detect that they're being impersonated by viewing the public keys attached to their account.\" In the following paragraph, privacy is mentioned: \"KT can better preserve user privacy by only showing entries of the log to participants that genuinely need to see them.\" It is unclear what it means to say that all entries are generally visible to all users, while achieving privacy through access control. Maybe the sentence can be rephrased to: \"Any malicious entries added to such a log will be visible to the owners and recipients of the public-keys, in which case a user can detect that they're being impersonated by viewing the public keys attached to their account\".",
      "createdAt": "2023-12-18T23:40:00Z",
      "updatedAt": "2024-02-05T19:13:30Z",
      "closedAt": "2024-02-05T19:13:30Z",
      "comments": []
    },
    {
      "number": 3,
      "id": "I_kwDOKhdr7c56DL5g",
      "title": "User Interactions",
      "url": "https://github.com/ietf-wg-keytrans/draft-arch/issues/3",
      "state": "CLOSED",
      "author": "eshaghoshms",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "pr-ready"
      ],
      "body": "For Search: Would it make sense to add the following: \" if the corresponding version does not exist, server should return a proof of non-inclusion\"? I am also wondering if it is important to exclude batch update from the definition of Update (Note that this means that new values are added to the log immediately and are not queued for later insertion with a batch of other values.) since most scalable systems will do batching at least to some degree.",
      "createdAt": "2023-12-18T23:43:54Z",
      "updatedAt": "2024-02-05T19:13:31Z",
      "closedAt": "2024-02-05T19:13:31Z",
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think that we can support proofs of non-inclusion, as they require leaking too much information about the number of entries in the database.\r\n\r\nI would support replacing language about \"batching\" with something that instead just captures the idea that there is no temporary SCT-style proof.",
          "createdAt": "2023-12-28T21:51:41Z",
          "updatedAt": "2023-12-28T21:51:41Z"
        },
        {
          "author": "eshaghoshms",
          "authorAssociation": "NONE",
          "body": "Isn't in crucial to support uniqueness of keys (i.e., given a certain username, the KT system should be able to return only one key as the latest)? I believe this uniqueness property implies support for non-inclusion proofs for the following reason. If there is no support for non-inclusion proof, the KT server could just claim (without any proof) that a certain username does not exist in the tree, when it actually does.",
          "createdAt": "2024-01-03T18:46:13Z",
          "updatedAt": "2024-01-03T18:46:13Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "NONE",
          "body": "Are we perhaps relying on owner signing for uniqueness of keys in the database? What if owner signing is not present -- how does the client know that the service provider isn't equivocating by showing two \"valid\" entries for the same username at the same epoch?\r\n\r\n> I don't think that we can support proofs of non-inclusion, as they require leaking too much information about the number of entries in the database.\r\n\r\nHm, I'm also curious about why this is the case. How do proofs of non-inclusion leak more info about the # of entries in the database, beyond what proofs of inclusion do?",
          "createdAt": "2024-01-03T19:00:37Z",
          "updatedAt": "2024-01-03T19:00:37Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "> Isn't in crucial to support uniqueness of keys (i.e., given a certain username, the KT system should be able to return only one key as the latest)? I believe this uniqueness property implies support for non-inclusion proofs for the following reason. If there is no support for non-inclusion proof, the KT server could just claim (without any proof) that a certain username does not exist in the tree, when it actually does.\r\n\r\nIf a proof of inclusion is provided, then that does convey a guarantee of uniqueness: this is the only value corresponding to this key. Functionally (and from a security perspective), proofs of non-inclusion aren't very useful because receiving a proof of non-inclusion results in the same user experience as the KT server simply being down. Either way, there's no risk of impersonation because no cryptographic material was provided.\r\n\r\n> Are we perhaps relying on owner signing for uniqueness of keys in the database?\r\n\r\nOwner Signing is not discussed\r\n\r\n> Hm, I'm also curious about why this is the case. How do proofs of non-inclusion leak more info about the # of entries in the database, beyond what proofs of inclusion do?\r\n\r\nYou can provide a proof of inclusion in a sparse Merkle tree, where empty subtrees are represented by a random hash. This would avoid leaking the number of populated leaves, as outside observers wouldn't be able to distinguish populated subtrees from random ones. To provide a proof of non-inclusion in this same type of tree would require showing that a subtree is empty, and the height of the empty subtree leaks information about the number of populated leaves.",
          "createdAt": "2024-01-03T21:02:11Z",
          "updatedAt": "2024-01-03T21:02:11Z"
        },
        {
          "author": "eshaghoshms",
          "authorAssociation": "NONE",
          "body": "I\u2019m curious why you think that a proof of inclusion is good enough for uniqueness? By proof-of-non-inclusion, I mean a cryptographic proof that the queried username does not exist in the database. To support uniqueness, the server should be able to provide a proof of the unique key corresponding to the queried username (if it exists in the database) or \"empty string\" to indicate that it does not. That is very different from no response from the server since the server is down. If the proof-of-non-inclusion is the same as no response, the server could exploit this to attack an account by distributing a fake key and proof-of-inclusion for the fake key to some parties, while simply not responding to some other, for the same username. Did you mean something else by proof-of-non-inclusion?\r\n\r\n> If a proof of inclusion is provided, then that does convey a guarantee of uniqueness: this is the only value corresponding to this key. Functionally (and from a security perspective), proofs of non-inclusion aren't very useful because receiving a proof of non-inclusion results in the same user experience as the KT server simply being down. Either way, there's no risk of impersonation because no cryptographic material was provided.\r\n\r\n",
          "createdAt": "2024-01-03T22:35:30Z",
          "updatedAt": "2024-01-03T22:36:32Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "We have the same understanding of what a proof of non-inclusion is. What you're describing isn't an attack. If I'm a user trying to lookup the public key of my friend, the server refusing to respond doesn't allow impersonation. However, if I'm trying to do monitoring, the server refusing to respond to my monitor queries would need to be handled the same as any cryptographic reason that monitoring might fail (the detection of a fork / other illegal changes to the tree)",
          "createdAt": "2024-01-04T00:30:01Z",
          "updatedAt": "2024-01-04T00:30:01Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "This conversation made me realize an interesting, privacy-preserving way to do proofs of non-inclusion for a key. When a user attempts to look up a key that doesn't exist, the server can insert version zero of the key with a special tombstone marker as its value. Subsequent lookups can reuse the same tombstone entry.\r\n\r\nThis obviously isn't something that makes sense to do for every application. As I said above, for most applications, a proof of non-inclusion and refusal to provide proof have the same UX and security value. But if a proof of non-inclusion would be particularly valuable, then this is an option.",
          "createdAt": "2024-01-04T02:37:29Z",
          "updatedAt": "2024-01-04T02:37:29Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "NONE",
          "body": "Ok, after re-reading carefully I think I understand how we are thinking about this differently. In Brendan's proposed architecture, each username is associated with a unique position in the sparse Merkle tree, which never changes, no matter how many times a new value is posted for that username.\r\n\r\nIn Esha's version, each leaf node in the Merkle tree is derived by the tuple (username || version #), so that updates to the value for a username increase this version # and result in different positions in the Merkle tree.\r\n\r\nIn Brendan's proposal, a proof of inclusion suffices for uniqueness because there is exactly one place to look for a username, regardless of how many times it was updated. Therefore, proof of non-inclusion is not needed.\r\n\r\n> To provide a proof of non-inclusion in this same type of tree would require showing that a subtree is empty, and the height of the empty subtree leaks information about the number of populated leaves.\r\n\r\nBtw Brendan, not sure if we understood this the same way, but: typically a proof of non-inclusion is not just a matter of showing that a subtree is empty. It instead consists of two proofs of inclusion of neighboring nodes in tree, which implies that since both of them are in the tree, and they are neighbors, then nothing in between them exists (hence a proof of non-inclusion for a target node). Hope that makes sense...\r\n\r\n---\r\n\r\nAnyway, I think it would be useful for us to perhaps spawn off a separate discussion / issue around the design of having static nodes in the tree for usernames that do not change no matter how many times the username's value is updated. I think there are some interesting tradeoffs which this approach -- I'll create a new issue to host that discussion if you don't mind!",
          "createdAt": "2024-01-04T21:31:38Z",
          "updatedAt": "2024-01-04T21:32:21Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOKhdr7c56DNiY",
      "title": "Deployment Modes and Out-of-Band Communication",
      "url": "https://github.com/ietf-wg-keytrans/draft-arch/issues/4",
      "state": "CLOSED",
      "author": "eshaghoshms",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "pr-ready"
      ],
      "body": "The relation between the Deployment Modes and Out-of-Band Communication is a bit unclear. Is Out-of-Band Communication assumed for all Deployment Modes? For example, the Contact Monitoring Mode says it is \"a single-party deployment with no third party\". But this would not be sufficient to detect forking attacks unless some Out-of-Band Communication or Bulletin Board is assumed.",
      "createdAt": "2023-12-18T23:49:10Z",
      "updatedAt": "2024-02-05T19:13:31Z",
      "closedAt": "2024-02-05T19:13:31Z",
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Out-of-Band Communication is available to detect forks in all deployment modes. Forking can still happen in the third-party modes if there's collusion",
          "createdAt": "2023-12-28T22:18:21Z",
          "updatedAt": "2023-12-28T22:18:21Z"
        },
        {
          "author": "eshaghoshms",
          "authorAssociation": "NONE",
          "body": "Thanks for the clarification! Can I suggest that we add this clarification in Section 5 as follows:\r\n\r\n_In the interest of satisfying the widest range of use-cases possible, three different modes for deploying a Transparency Log are supported. Each mode has slightly different requirements and efficiency considerations for both the transparency log and the end-user._\r\n\r\nto\r\n\r\n_In the interest of satisfying the widest range of use-cases possible, three different modes for deploying a Transparency Log are supported. Each mode has slightly different requirements and efficiency considerations for both the transparency log and the end-user. **Note that Out-of-Band Communication is necessary to detect forks in all of these deployment modes.**_",
          "createdAt": "2024-01-03T21:38:50Z",
          "updatedAt": "2024-01-03T21:38:50Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Go for it",
          "createdAt": "2024-01-04T00:31:39Z",
          "updatedAt": "2024-01-04T00:31:39Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOKhdr7c56DQU5",
      "title": "Security Guarantees",
      "url": "https://github.com/ietf-wg-keytrans/draft-arch/issues/5",
      "state": "OPEN",
      "author": "eshaghoshms",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Some additional parameters that would be nice to add in Section 6 (The parameters that determine the maximum amount of time before malicious behavior is detected are as follows:)\r\n\r\n1. What state is needed to be maintained by the client devices to detect malicious behavior\r\n2. What state the client devices need to maintain about the user's contacts to help detect malicious behavior\r\n3. Who detects the malicious behavior: the owner of the key, or its recipient\r\n\r\n\r\n\r\n",
      "createdAt": "2023-12-18T23:57:28Z",
      "updatedAt": "2023-12-19T01:04:05Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 6,
      "id": "I_kwDOKhdr7c56DSqg",
      "title": "Leakage to Third-Party",
      "url": "https://github.com/ietf-wg-keytrans/draft-arch/issues/6",
      "state": "OPEN",
      "author": "eshaghoshms",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I suggest editing the following text in Section 6.1.1\r\n\r\n_In the event that a third-party auditor or manager is used, there\u2019s additional information leaked to the third-party that\u2019s not visible to outsiders.\r\nIn the case of a third-party auditor, the auditor is able to learn the total number of distinct keys in the log. It is also able to distinguish between real and fake modifications to the tree, and keep track of when individual keys are modified. However, auditors are not able to learn the plaintext values of any keys or values. This is because keys are masked with a VRF, and values are only provided to auditors as commitments._\r\n\r\nto\r\n\r\n_In the event that a third-party auditor or manager is used, there might be additional information leaked to the third-party that\u2019s not visible to outsiders. However, in the case of a third-party auditor, auditors are not able to learn the plaintext values of any keys or values. This is because keys are masked with a VRF, and values are only provided to auditors as commitments._\r\n \r\nThis is because many of the KT systems so not suffer from the extra leakage mentioned in the text leakage: SEEMless, VeRSA, Verdict, Parakeet, ELEKTRA. ",
      "createdAt": "2023-12-19T00:04:00Z",
      "updatedAt": "2024-01-26T23:51:20Z",
      "closedAt": null,
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I was inclined to agree with this, but when thinking about it deeper I realized I'm not sure how to do this and also support Contact Monitoring. This might be something we need to revisit with a specific construction in mind",
          "createdAt": "2024-01-25T20:04:16Z",
          "updatedAt": "2024-01-25T20:04:16Z"
        },
        {
          "author": "eshaghoshms",
          "authorAssociation": "NONE",
          "body": "@Bren2010 : I edited the suggestion to be more precise. I believe leaking the plaintext can be avoided (even in Contact Monitoring mode) by applying VRF and commitments. Does this make sense?",
          "createdAt": "2024-01-26T06:36:25Z",
          "updatedAt": "2024-01-26T06:36:25Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "The existing text already says that keys and values are not leaked. In your updated comment, you just remove these sentences:\r\n\r\n> In the case of a third-party auditor, the auditor is able to learn the total number of distinct keys in the log. It is also able to distinguish between real and fake modifications to the tree, and keep track of when individual keys are modified.\r\n\r\nThis is the leakage I don't know how to avoid",
          "createdAt": "2024-01-26T23:51:01Z",
          "updatedAt": "2024-01-26T23:51:20Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOKhdr7c58vFD5",
      "title": "Discuss compaction",
      "url": "https://github.com/ietf-wg-keytrans/draft-arch/issues/8",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-01-21T18:47:43Z",
      "updatedAt": "2024-03-04T20:00:21Z",
      "closedAt": "2024-03-04T20:00:21Z",
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 7,
      "id": "PR_kwDOKhdr7c5knInp",
      "title": "Resolve easy issues",
      "url": "https://github.com/ietf-wg-keytrans/draft-arch/pull/7",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #2, #3, #4\r\n/cc @kevinlewi @eshaghoshms",
      "createdAt": "2024-01-20T00:54:06Z",
      "updatedAt": "2024-02-05T19:13:29Z",
      "baseRepository": "ietf-wg-keytrans/draft-arch",
      "baseRefName": "main",
      "baseRefOid": "b9aaa14cb7468dffeae926ac33ef0354e76a5950",
      "headRepository": "ietf-wg-keytrans/draft-arch",
      "headRefName": "brendan/bugs",
      "headRefOid": "c66112e2c5b4bd4dde5dba6c4fcf0df2d5e60058",
      "closedAt": "2024-02-05T19:13:29Z",
      "mergedAt": "2024-02-05T19:13:29Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "bb25dd8a5b33d52704f34ff2008e79e966a4f268"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "NONE",
          "body": "I think this closes #2, #3, and #4, but not #6 right? Is #6 addressed in this PR (did I miss it)?",
          "createdAt": "2024-01-24T22:51:56Z",
          "updatedAt": "2024-01-24T22:51:56Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, #6 is not addressed. I made a comment in that ticket addressing why it was removed",
          "createdAt": "2024-01-25T20:05:06Z",
          "updatedAt": "2024-01-25T20:05:06Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKhdr7c5tgtrF",
          "commit": {
            "abbreviatedOid": "b9fe308"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-22T20:21:20Z",
          "updatedAt": "2024-01-22T20:21:20Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nin which case a user can detect that they are being impersonated\r\n```",
              "createdAt": "2024-01-22T20:21:20Z",
              "updatedAt": "2024-01-22T20:21:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKhdr7c5tguiI",
          "commit": {
            "abbreviatedOid": "b9fe308"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-22T20:23:12Z",
          "updatedAt": "2024-01-22T20:23:13Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "```suggestion\r\n   to the log immediately and no provisional inclusion proof, such as an SCT as defined in {{Section 4.4 of RFC9162}}, is provided.\r\n```",
              "createdAt": "2024-01-22T20:23:12Z",
              "updatedAt": "2024-02-05T19:12:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKhdr7c5tgvXk",
          "commit": {
            "abbreviatedOid": "b9fe308"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-22T20:25:21Z",
          "updatedAt": "2024-01-22T20:25:21Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "perhaps \"resolved\" instead of \"looked-up\" ?",
              "createdAt": "2024-01-22T20:25:21Z",
              "updatedAt": "2024-01-22T20:25:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKhdr7c5tgvdz",
          "commit": {
            "abbreviatedOid": "b9fe308"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-22T20:25:38Z",
          "updatedAt": "2024-01-22T20:25:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 9,
      "id": "PR_kwDOKhdr7c5mF2b9",
      "title": "Write section on privacy law compliance.",
      "url": "https://github.com/ietf-wg-keytrans/draft-arch/pull/9",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-02-06T02:25:12Z",
      "updatedAt": "2024-02-14T23:50:32Z",
      "baseRepository": "ietf-wg-keytrans/draft-arch",
      "baseRefName": "main",
      "baseRefOid": "073f63d7c7e8ade3c272f03151b3c659de71e2e4",
      "headRepository": "ietf-wg-keytrans/draft-arch",
      "headRefName": "brendan/gdpr",
      "headRefOid": "6b6008b8c1672d853ebda8b0875aa992a810f090",
      "closedAt": "2024-02-14T23:50:32Z",
      "mergedAt": "2024-02-14T23:50:32Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "12854ab1ed4b1cc9b54839dd4d343d9f0dd03e5c"
      },
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "> Again, I'm not saying that my worries should be addressed in this PR, but I think it would be better to work on a list of requirements that a KT design must provide and then proceed to the design.\r\n\r\nThis PR does go into the construction more than would be ideal, but solely for explanatory reasons. If we asserted that entry deletion must be possible without discussing how we plan to do that, people would jump too quickly to \"this is impossible\"",
          "createdAt": "2024-02-07T18:03:09Z",
          "updatedAt": "2024-02-07T18:03:09Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKhdr7c5vHcCo",
          "commit": {
            "abbreviatedOid": "1dd3f1b"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "This seems to make some assumptions about the logs construction that perhaps are beyond the architecture.\n\nI find myself wishing for a simple concrete example to look at, to be assured of these properties.",
          "createdAt": "2024-02-06T03:33:15Z",
          "updatedAt": "2024-02-06T03:33:15Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKhdr7c5vSxki",
          "commit": {
            "abbreviatedOid": "1dd3f1b"
          },
          "author": "felixlinker",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "My sentiment is the same as for #10, but I am a bit more positive here. My understanding is that this PR shows how deletion requests can be supported in a KT system using the standard construction, i.e., you show that it is possible to implement the requirement of \"entry deletion must be possible.\"\r\n\r\nNevertheless, reading what you wrote, I started thinking: \"But will that actually work?\" Couldn't the mechanism as described here lead to equivocation attacks where a provider tells some clients that an entry was deleted and others that it was not? Maybe we require a tombstoning mechanism (as in #10)?\r\n\r\nAgain, I'm not saying that my worries should be addressed in this PR, but I think it would be better to work on a list of requirements that a KT design must provide and then proceed to the design.",
          "createdAt": "2024-02-07T08:30:06Z",
          "updatedAt": "2024-02-07T08:30:06Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKhdr7c5vb3-Q",
          "commit": {
            "abbreviatedOid": "71333b6"
          },
          "author": "felixlinker",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-08T08:53:35Z",
          "updatedAt": "2024-02-08T08:53:35Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKhdr7c5v_x6W",
          "commit": {
            "abbreviatedOid": "71333b6"
          },
          "author": "thibmeu",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I concur with previous reviews that the example might be too much for an architecture doc, but seems scoped enough to ease comprehension, without suggesting a specific implementation.",
          "createdAt": "2024-02-13T21:46:07Z",
          "updatedAt": "2024-02-13T21:49:12Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n# Privacy Law Consideration\r\n```\r\ncompliance may be too much",
              "createdAt": "2024-02-13T21:46:07Z",
              "updatedAt": "2024-02-13T21:49:12Z"
            }
          ]
        }
      ]
    },
    {
      "number": 10,
      "id": "PR_kwDOKhdr7c5mF2hK",
      "title": "Discuss combining and retiring logs.",
      "url": "https://github.com/ietf-wg-keytrans/draft-arch/pull/10",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Resolves #1 ",
      "createdAt": "2024-02-06T02:25:40Z",
      "updatedAt": "2024-02-15T00:09:24Z",
      "baseRepository": "ietf-wg-keytrans/draft-arch",
      "baseRefName": "main",
      "baseRefOid": "073f63d7c7e8ade3c272f03151b3c659de71e2e4",
      "headRepository": "ietf-wg-keytrans/draft-arch",
      "headRefName": "brendan/combinations",
      "headRefOid": "9809e1c5fe31730c9f2686ac95c95e1d64aa0b24",
      "closedAt": "2024-02-15T00:09:24Z",
      "mergedAt": "2024-02-15T00:09:24Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "f6fc19ea68950ae41bd1cf5cdbf4a08574131684"
      },
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "NONE",
          "body": "> Resolves #1\r\n\r\nFWIW, I think this text is good enough for the present, but it does seem to omit a case that's been seen in the past - where a log suffers a poisoning or DoS attack or otherwise becomes practically useless, but where the log operator is not trying to be dishonest. I'm fine that the detail is considered later but might be worth a mention now as another case.",
          "createdAt": "2024-02-06T20:14:08Z",
          "updatedAt": "2024-02-06T20:14:08Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "> Or am I getting the process wrong? My understanding was that the KT architecture document is supposed to align the work of the WG at a high level, not provide a design.\r\n\r\nI don't believe there is any real protocol design happening here. It is a statement of architecture to say that there will be multiple logs operating independently, clients will likely be communicating with multiple logs, and clients are responsible for communicating with multiple logs in a way that is secure. And then we give some examples of how to communicate with multiple logs securely -- emphasizing that these are examples and not standardized behavior. Does that address your concern?",
          "createdAt": "2024-02-07T17:19:27Z",
          "updatedAt": "2024-02-07T17:19:27Z"
        },
        {
          "author": "felixlinker",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I don't believe there is any real protocol design happening here. It is a statement of architecture to say that there will be multiple logs operating independently, clients will likely be communicating with multiple logs, and clients are responsible for communicating with multiple logs in a way that is secure. And then we give some examples of how to communicate with multiple logs securely -- emphasizing that these are examples and not standardized behavior. Does that address your concern?\r\n\r\nYou are right, this is not protocol design. I guess my problem lies more in mandating that the design provides federation. #1 raised the issue of what should happen if one key server becomes unavailable. I agree that it is an important to provide a mechanism for log migration (i.e., you \"import\" a state of some other log). Log migration has the benefit, though, that one log becomes stale and you don't expect any updates to it.\r\n\r\nProviding full on federation where you would like to see updates to key-mappings in multiple logs is much harder as you need to find policies to decide what to do in case of conflicts, etc. You don't need federation to solve #1. I can see benefits to it, but also many problems in practice so I wouldn't commit to federation now.",
          "createdAt": "2024-02-08T09:01:12Z",
          "updatedAt": "2024-02-08T09:01:12Z"
        },
        {
          "author": "robinbryce",
          "authorAssociation": "NONE",
          "body": "This wording I think also helps deal with the pragmatic problem of log format evolution. For whatever reason multiple logs are used though, Is it worth including some words about how to place the logs in a series? If the log entries include a commitment to some time series or intrinsically encode log position in their entries, then puting the last valid root of the previous log in the next could make it clear that the retired log was 'complete' and any subequent entries are invalid.",
          "createdAt": "2024-02-10T10:02:35Z",
          "updatedAt": "2024-02-10T10:02:35Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKhdr7c5vHcTM",
          "commit": {
            "abbreviatedOid": "dba8317"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-06T03:35:04Z",
          "updatedAt": "2024-02-06T03:42:25Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "What happens if conflicts exist? Why not MUST?",
              "createdAt": "2024-02-06T03:35:04Z",
              "updatedAt": "2024-02-06T03:42:25Z"
            },
            {
              "originalPosition": 25,
              "body": "I wonder if an example policy might make this clearer... It reads as \" the service provider should have a policy of not being duplicitous\"...but if that is detectable, what does this MUST really unlock?",
              "createdAt": "2024-02-06T03:39:02Z",
              "updatedAt": "2024-02-06T03:42:25Z"
            },
            {
              "originalPosition": 46,
              "body": "Again what happens when this doesn't happen, why not MUST?",
              "createdAt": "2024-02-06T03:40:34Z",
              "updatedAt": "2024-02-06T03:42:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKhdr7c5vOUBN",
          "commit": {
            "abbreviatedOid": "dba8317"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-06T18:15:42Z",
          "updatedAt": "2024-02-06T18:15:42Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "\"SHOULD\" because I think supporting multiple logs should be the default decision, unless an implementer really really knows they're only ever going to talk to one log at a time",
              "createdAt": "2024-02-06T18:15:42Z",
              "updatedAt": "2024-02-06T18:15:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKhdr7c5vOVIo",
          "commit": {
            "abbreviatedOid": "dba8317"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-06T18:18:33Z",
          "updatedAt": "2024-02-06T18:18:33Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "This \"MUST\" doesn't affect the service provider, it's saying all of the users need to behave in a consistent way. If they don't, it gets very hard to reason about whether security guarantees are met",
              "createdAt": "2024-02-06T18:18:33Z",
              "updatedAt": "2024-02-06T18:18:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKhdr7c5vSnrB",
          "commit": {
            "abbreviatedOid": "28f43ae"
          },
          "author": "felixlinker",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I worry that this addition to the architecture document introduces more problems than it solves. I liked the initial architecture document because it described what I presume that _every_ KT system will do at a high-level. This PR now reduces the design space and vaguely commits us to a specific design trying to address #1.\r\n\r\nFor example, with this PR, I worry that providing federated logs might over-complicate the design without providing much value. For example, you could also gain the benefits of a federated setup (load balancing, redundancy) from a setup that is federated \"behind the scenes.\" A KT provider could simply store its tree in a distributed database, but clients and auditors use one API endpoint and need not care how the provider manages to reply to their queries. I do not claim that this is a better design, but I do think we need to discuss what is the best design.\r\n\r\nBefore we start designing a KT system, I think it would be better to identify requirements that a KT design must implement (e.g., being able to migrate from log A to log B) and leave it there. With the requirements set out, we can then start working on a new design document.\r\n\r\nOr am I getting the process wrong? My understanding was that the KT architecture document is supposed to align the work of the WG at a high level, not provide a design.",
          "createdAt": "2024-02-07T08:07:10Z",
          "updatedAt": "2024-02-07T08:23:09Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "\"Tombstone\" is used here for the first time without further definition. I think this is a concept that was first introduced in SEEMless and requires introduction.",
              "createdAt": "2024-02-07T08:07:11Z",
              "updatedAt": "2024-02-07T08:23:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKhdr7c5vznU3",
          "commit": {
            "abbreviatedOid": "dba8317"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-12T17:29:22Z",
          "updatedAt": "2024-02-12T17:29:22Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "So this is a policy suggestion for \"clients\" ? maybe client is a better word than user here.... saying \"must be consistent\" without further clarity remains triggering for me, but your answer to makes sense to me.",
              "createdAt": "2024-02-12T17:29:22Z",
              "updatedAt": "2024-02-12T17:29:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKhdr7c5v_too",
          "commit": {
            "abbreviatedOid": "4b5566a"
          },
          "author": "thibmeu",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T21:34:05Z",
          "updatedAt": "2024-02-13T21:45:14Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\n- A service provider MAY decide that it's prudent to rotate its cryptographic\r\n```\r\nis this MAY, or only a suggestion?",
              "createdAt": "2024-02-13T21:34:05Z",
              "updatedAt": "2024-02-13T21:45:14Z"
            },
            {
              "originalPosition": 17,
              "body": "do you envision sharding to be used, by year for instance? I have the impression it provides a slightly more concrete example.",
              "createdAt": "2024-02-13T21:36:46Z",
              "updatedAt": "2024-02-13T21:45:14Z"
            },
            {
              "originalPosition": 62,
              "body": "```suggestion\r\n1. Search queries must be executed against the new log.\r\n```\r\nsemantic, should always is a must I would say",
              "createdAt": "2024-02-13T21:39:23Z",
              "updatedAt": "2024-02-13T21:45:14Z"
            },
            {
              "originalPosition": 89,
              "body": "for an HTTP request, this would be `no-store`/`private`?",
              "createdAt": "2024-02-13T21:44:41Z",
              "updatedAt": "2024-02-13T21:45:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKhdr7c5wJbZi",
          "commit": {
            "abbreviatedOid": "4b5566a"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-14T23:55:47Z",
          "updatedAt": "2024-02-15T00:08:31Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Mentioning more as a possibility than a protocol mechanism",
              "createdAt": "2024-02-14T23:55:47Z",
              "updatedAt": "2024-02-15T00:08:31Z"
            },
            {
              "originalPosition": 89,
              "body": "I think we are looking at something more like OHAI. So the server in the federation that I rely on can anonymize my requests to other servers, but doesn't end up observing a bunch of private user data.",
              "createdAt": "2024-02-15T00:08:21Z",
              "updatedAt": "2024-02-15T00:08:31Z"
            }
          ]
        }
      ]
    },
    {
      "number": 11,
      "id": "PR_kwDOKhdr7c5nCYjL",
      "title": "Write section on pruning",
      "url": "https://github.com/ietf-wg-keytrans/draft-arch/pull/11",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-02-16T00:31:23Z",
      "updatedAt": "2024-03-04T20:00:20Z",
      "baseRepository": "ietf-wg-keytrans/draft-arch",
      "baseRefName": "main",
      "baseRefOid": "b3d139296e0554c7c285daf0d07ab0b6c6ece984",
      "headRepository": "ietf-wg-keytrans/draft-arch",
      "headRefName": "brendan/prune",
      "headRefOid": "5bcfec12da753b74bf003d7682ecc3bf8fd19941",
      "closedAt": "2024-03-04T20:00:20Z",
      "mergedAt": "2024-03-04T20:00:20Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "7ab2ad33c6b7c58565a4a14c006c32314f01ef1e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKhdr7c5xvlXE",
          "commit": {
            "abbreviatedOid": "5bcfec1"
          },
          "author": "felixlinker",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "If one can say something about that, it might also be worthwhile to point out how pruning affects log growth. With pruning and assuming a user-base of constant size for the sake of the argument; is there a limit to the size of the log? This would be a desirable property. But I don't know whether this is true (or under what conditions).",
          "createdAt": "2024-02-29T08:51:47Z",
          "updatedAt": "2024-02-29T08:51:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 12,
      "id": "PR_kwDOKhdr7c5nH3VD",
      "title": "Write about how to preserve anonymity",
      "url": "https://github.com/ietf-wg-keytrans/draft-arch/pull/12",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-02-16T19:14:06Z",
      "updatedAt": "2024-03-04T20:06:38Z",
      "baseRepository": "ietf-wg-keytrans/draft-arch",
      "baseRefName": "main",
      "baseRefOid": "a7ebacec537afcbc47ac9459beb4b379f3e75bb3",
      "headRepository": "ietf-wg-keytrans/draft-arch",
      "headRefName": "brendan/sealed-sender",
      "headRefOid": "0e8d28fb4e18ef5f87def0afa7e15ffefa42249a",
      "closedAt": "2024-03-04T20:06:38Z",
      "mergedAt": "2024-03-04T20:06:38Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "f68a99ff8b2ed01dbe38201306a6bb30134eec1c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKhdr7c5xvfBz",
          "commit": {
            "abbreviatedOid": "51148b8"
          },
          "author": "felixlinker",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "In general, I find this a good clarification. It took me quite a while to understand the paragraph starting with \"Strong credentials...\" so I made some suggestions to (hopefully) be a bit more clear! :)",
          "createdAt": "2024-02-29T08:38:14Z",
          "updatedAt": "2024-02-29T08:47:27Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\nThis means users generally interact directly with the transparency log. The\r\n```",
              "createdAt": "2024-02-29T08:38:14Z",
              "updatedAt": "2024-02-29T08:47:27Z"
            },
            {
              "originalPosition": 28,
              "body": "```suggestion\r\npotentially several encryption or signature public keys, and are meant to be\r\nverified with no/minimal network requests by the receiving users.\r\n```",
              "createdAt": "2024-02-29T08:38:53Z",
              "updatedAt": "2024-03-04T20:02:14Z"
            },
            {
              "originalPosition": 32,
              "body": "```suggestion\r\nIn particular, credentials that can be verified with minimal network access are\r\noften required by applications provide anonymous communication. These\r\napplications provide end-to-end encryption with a protocol\r\n```",
              "createdAt": "2024-02-29T08:40:14Z",
              "updatedAt": "2024-02-29T08:47:27Z"
            },
            {
              "originalPosition": 41,
              "body": "```suggestion\r\nhandshake messages required), or Sealed Sender {{sealed-sender}}. When a user\r\nreceives a message, these protocols have senders provide their own credential in\r\nan encrypted portion of the message. Encrypting the sender's credential prevents\r\nit from being visible to the service provider, while still assuring the\r\nrecipient of the sender's identity. If users were to authenticate the sender's\r\npublic key directly with the service provider, they would leak to the service\r\nprovider who the they are communicating with.\r\n```",
              "createdAt": "2024-02-29T08:45:44Z",
              "updatedAt": "2024-02-29T08:47:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 13,
      "id": "PR_kwDOKhdr7c5oo7UG",
      "title": "Reduce leakage from KT log",
      "url": "https://github.com/ietf-wg-keytrans/draft-arch/pull/13",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-03-04T21:11:01Z",
      "updatedAt": "2024-03-04T22:49:35Z",
      "baseRepository": "ietf-wg-keytrans/draft-arch",
      "baseRefName": "main",
      "baseRefOid": "f68a99ff8b2ed01dbe38201306a6bb30134eec1c",
      "headRepository": "ietf-wg-keytrans/draft-arch",
      "headRefName": "brendan/leakage",
      "headRefOid": "320a9c236e27fe791450e20467774fe79c9e76ba",
      "closedAt": "2024-03-04T22:49:35Z",
      "mergedAt": "2024-03-04T22:49:35Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "b32f9091619252aa08ffa01fd7cebc2c660e39c2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKhdr7c5yKnXI",
          "commit": {
            "abbreviatedOid": "320a9c2"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-04T21:27:12Z",
          "updatedAt": "2024-03-04T21:27:12Z",
          "comments": []
        }
      ]
    }
  ]
}